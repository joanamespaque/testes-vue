{"remainingRequest":"/home/joana/projeto-vue/func-project/node_modules/babel-loader/lib/index.js!/home/joana/projeto-vue/func-project/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/home/joana/projeto-vue/func-project/node_modules/vuetify/lib/util/mergeData.js","mtime":499162500000},{"path":"/home/joana/projeto-vue/func-project/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/joana/projeto-vue/func-project/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiL2hvbWUvam9hbmEvcHJvamV0by12dWUvZnVuYy1wcm9qZWN0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZCI7CmltcG9ydCBfQXJyYXkkaXNBcnJheSBmcm9tICIvaG9tZS9qb2FuYS9wcm9qZXRvLXZ1ZS9mdW5jLXByb2plY3Qvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9hcnJheS9pcy1hcnJheSI7CmltcG9ydCBfT2JqZWN0JGtleXMgZnJvbSAiL2hvbWUvam9hbmEvcHJvamV0by12dWUvZnVuYy1wcm9qZWN0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2NvcmUtanMvb2JqZWN0L2tleXMiOwppbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSAiL2hvbWUvam9hbmEvcHJvamV0by12dWUvZnVuYy1wcm9qZWN0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMyL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0IjsKaW1wb3J0IF9nZXRJdGVyYXRvciBmcm9tICIvaG9tZS9qb2FuYS9wcm9qZXRvLXZ1ZS9mdW5jLXByb2plY3Qvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvY29yZS1qcy9nZXQtaXRlcmF0b3IiOwppbXBvcnQgeyBjYW1lbGl6ZSB9IGZyb20gJy4vaGVscGVycyc7CnZhciBwYXR0ZXJuID0gewogIHN0eWxlTGlzdDogLzsoPyFbXihdKlwpKS9nLAogIHN0eWxlUHJvcDogLzooLiopLwp9OwoKZnVuY3Rpb24gcGFyc2VTdHlsZShzdHlsZSkgewogIHZhciBzdHlsZU1hcCA9IHt9OwogIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTsKICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTsKICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7CgogIHRyeSB7CiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBfZ2V0SXRlcmF0b3Ioc3R5bGUuc3BsaXQocGF0dGVybi5zdHlsZUxpc3QpKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkgewogICAgICB2YXIgcyA9IF9zdGVwLnZhbHVlOwoKICAgICAgdmFyIF9zJHNwbGl0ID0gcy5zcGxpdChwYXR0ZXJuLnN0eWxlUHJvcCksCiAgICAgICAgICBfcyRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfcyRzcGxpdCwgMiksCiAgICAgICAgICBrZXkgPSBfcyRzcGxpdDJbMF0sCiAgICAgICAgICB2YWwgPSBfcyRzcGxpdDJbMV07CgogICAgICBrZXkgPSBrZXkudHJpbSgpOwoKICAgICAgaWYgKCFrZXkpIHsKICAgICAgICBjb250aW51ZTsKICAgICAgfSAvLyBNYXkgYmUgdW5kZWZpbmVkIGlmIHRoZSBga2V5OiB2YWx1ZWAgcGFpciBpcyBpbmNvbXBsZXRlLgoKCiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgewogICAgICAgIHZhbCA9IHZhbC50cmltKCk7CiAgICAgIH0KCiAgICAgIHN0eWxlTWFwW2NhbWVsaXplKGtleSldID0gdmFsOwogICAgfQogIH0gY2F0Y2ggKGVycikgewogICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlOwogICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7CiAgfSBmaW5hbGx5IHsKICAgIHRyeSB7CiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHsKICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7CiAgICAgIH0KICAgIH0gZmluYWxseSB7CiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikgewogICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gc3R5bGVNYXA7Cn0KCmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlRGF0YSgpIHsKICB2YXIgbWVyZ2VUYXJnZXQgPSB7fTsKICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgdmFyIHByb3A7CiAgdmFyIGV2ZW50OyAvLyBBbGxvdyBmb3IgdmFyaWFkaWMgYXJndW1lbnQgbGVuZ3RoLgoKICB3aGlsZSAoaS0tKSB7CiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGRhdGEgcHJvcGVydGllcyBhbmQgZXhlY3V0ZSBtZXJnZSBzdHJhdGVnaWVzCiAgICAvLyBPYmplY3Qua2V5cyBlbGltaW5hdGVzIG5lZWQgZm9yIGhhc093blByb3BlcnR5IGNhbGwKICAgIHZhciBfYXJyID0gX09iamVjdCRrZXlzKGFyZ3VtZW50c1tpXSk7CgogICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7CiAgICAgIHByb3AgPSBfYXJyW19pXTsKCiAgICAgIHN3aXRjaCAocHJvcCkgewogICAgICAgIC8vIEFycmF5IG1lcmdlIHN0cmF0ZWd5IChhcnJheSBjb25jYXRlbmF0aW9uKQogICAgICAgIGNhc2UgJ2NsYXNzJzoKICAgICAgICBjYXNlICdzdHlsZSc6CiAgICAgICAgY2FzZSAnZGlyZWN0aXZlcyc6CiAgICAgICAgICBpZiAoIWFyZ3VtZW50c1tpXVtwcm9wXSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIV9BcnJheSRpc0FycmF5KG1lcmdlVGFyZ2V0W3Byb3BdKSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IFtdOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChwcm9wID09PSAnc3R5bGUnKSB7CiAgICAgICAgICAgIHZhciBzdHlsZSA9IHZvaWQgMDsKCiAgICAgICAgICAgIGlmIChfQXJyYXkkaXNBcnJheShhcmd1bWVudHNbaV0uc3R5bGUpKSB7CiAgICAgICAgICAgICAgc3R5bGUgPSBhcmd1bWVudHNbaV0uc3R5bGU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgc3R5bGUgPSBbYXJndW1lbnRzW2ldLnN0eWxlXTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHlsZS5sZW5ndGg7IGorKykgewogICAgICAgICAgICAgIHZhciBzID0gc3R5bGVbal07CgogICAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgIHN0eWxlW2pdID0gcGFyc2VTdHlsZShzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGFyZ3VtZW50c1tpXS5zdHlsZSA9IHN0eWxlOwogICAgICAgICAgfSAvLyBSZXBhY2thZ2luZyBpbiBhbiBhcnJheSBhbGxvd3MgVnVlIHJ1bnRpbWUKICAgICAgICAgIC8vIHRvIG1lcmdlIGNsYXNzL3N0eWxlIGJpbmRpbmdzIHJlZ2FyZGxlc3Mgb2YgdHlwZS4KCgogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBtZXJnZVRhcmdldFtwcm9wXS5jb25jYXQoYXJndW1lbnRzW2ldW3Byb3BdKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIFNwYWNlIGRlbGltaXRlZCBzdHJpbmcgY29uY2F0ZW5hdGlvbiBzdHJhdGVneQoKICAgICAgICBjYXNlICdzdGF0aWNDbGFzcyc6CiAgICAgICAgICBpZiAoIWFyZ3VtZW50c1tpXVtwcm9wXSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAobWVyZ2VUYXJnZXRbcHJvcF0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9ICcnOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICAvLyBOb3QgYW4gZW1wdHkgc3RyaW5nLCBzbyBjb25jYXRlbmF0ZQogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSArPSAnICc7CiAgICAgICAgICB9CgogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gKz0gYXJndW1lbnRzW2ldW3Byb3BdLnRyaW0oKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIE9iamVjdCwgdGhlIHByb3BlcnRpZXMgb2Ygd2hpY2ggdG8gbWVyZ2UgdmlhIGFycmF5IG1lcmdlIHN0cmF0ZWd5IChhcnJheSBjb25jYXRlbmF0aW9uKS4KICAgICAgICAvLyBDYWxsYmFjayBtZXJnZSBzdHJhdGVneSBtZXJnZXMgY2FsbGJhY2tzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LAogICAgICAgIC8vIHNvIHRoYXQgdGhlIGxhc3QgZGVmaW5lZCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgZmlyc3QuCiAgICAgICAgLy8gVGhpcyBpcyBkb25lIHNpbmNlIHRvIG1pbWljIGhvdyBPYmplY3QuYXNzaWduIG1lcmdpbmcKICAgICAgICAvLyB1c2VzIHRoZSBsYXN0IGdpdmVuIHZhbHVlIHRvIGFzc2lnbi4KCiAgICAgICAgY2FzZSAnb24nOgogICAgICAgIGNhc2UgJ25hdGl2ZU9uJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghbWVyZ2VUYXJnZXRbcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSB7fTsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gbWVyZ2VUYXJnZXRbcHJvcF07CgogICAgICAgICAgdmFyIF9hcnIyID0gX09iamVjdCRrZXlzKGFyZ3VtZW50c1tpXVtwcm9wXSB8fCB7fSk7CgogICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX2FycjIubGVuZ3RoOyBfaTIrKykgewogICAgICAgICAgICBldmVudCA9IF9hcnIyW19pMl07CgogICAgICAgICAgICAvLyBDb25jYXQgZnVuY3Rpb24gdG8gYXJyYXkgb2YgZnVuY3Rpb25zIGlmIGNhbGxiYWNrIHByZXNlbnQuCiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbZXZlbnRdKSB7CiAgICAgICAgICAgICAgLy8gSW5zZXJ0IGN1cnJlbnQgaXRlcmF0aW9uIGRhdGEgaW4gYmVnaW5uaW5nIG9mIG1lcmdlZCBhcnJheS4KICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gQXJyYXkoKS5jb25jYXQoIC8vIGVzbGludC1kaXNhYmxlLWxpbmUKICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdLCBhcmd1bWVudHNbaV1bcHJvcF1bZXZlbnRdKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAvLyBTdHJhaWdodCBhc3NpZ24uCiAgICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGFyZ3VtZW50c1tpXVtwcm9wXVtldmVudF07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICAvLyBPYmplY3QgbWVyZ2Ugc3RyYXRlZ3kKCiAgICAgICAgY2FzZSAnYXR0cnMnOgogICAgICAgIGNhc2UgJ3Byb3BzJzoKICAgICAgICBjYXNlICdkb21Qcm9wcyc6CiAgICAgICAgY2FzZSAnc2NvcGVkU2xvdHMnOgogICAgICAgIGNhc2UgJ3N0YXRpY1N0eWxlJzoKICAgICAgICBjYXNlICdob29rJzoKICAgICAgICBjYXNlICd0cmFuc2l0aW9uJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghbWVyZ2VUYXJnZXRbcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSB7fTsKICAgICAgICAgIH0KCiAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IF9vYmplY3RTcHJlYWQoe30sIGFyZ3VtZW50c1tpXVtwcm9wXSwgbWVyZ2VUYXJnZXRbcHJvcF0pOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gUmVhc3NpZ25tZW50IHN0cmF0ZWd5IChubyBtZXJnZSkKCiAgICAgICAgY2FzZSAnc2xvdCc6CiAgICAgICAgY2FzZSAna2V5JzoKICAgICAgICBjYXNlICdyZWYnOgogICAgICAgIGNhc2UgJ3RhZyc6CiAgICAgICAgY2FzZSAnc2hvdyc6CiAgICAgICAgY2FzZSAna2VlcEFsaXZlJzoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgaWYgKCFtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IGFyZ3VtZW50c1tpXVtwcm9wXTsKICAgICAgICAgIH0KCiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBtZXJnZVRhcmdldDsKfQ=="},{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n  let event: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = []\n          }\n\n          if (prop === 'style') {\n            let style: any[]\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style\n            } else {\n              style = [arguments[i].style]\n            }\n            for (let j = 0; j < style.length; j++) {\n              const s = style[j]\n              if (typeof s === 'string') {\n                style[j] = parseStyle(s)\n              }\n            }\n            arguments[i].style = style\n          }\n\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop])\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          const listeners = mergeTarget[prop]!\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array<Function>().concat( // eslint-disable-line\n                listeners[event],\n                arguments[i][prop][event]\n              )\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event]\n            }\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n"],"sourceRoot":""}]}