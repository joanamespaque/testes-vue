{"remainingRequest":"/home/joana/pasta-teste/projeto-vue/func-project/node_modules/babel-loader/lib/index.js!/home/joana/pasta-teste/projeto-vue/func-project/node_modules/vuetify/lib/util/mergeData.js","dependencies":[{"path":"/home/joana/pasta-teste/projeto-vue/func-project/node_modules/vuetify/lib/util/mergeData.js","mtime":499162500000},{"path":"/home/joana/pasta-teste/projeto-vue/func-project/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/joana/pasta-teste/projeto-vue/func-project/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nIjsKaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICIvaG9tZS9qb2FuYS9wYXN0YS10ZXN0ZS9wcm9qZXRvLXZ1ZS9mdW5jLXByb2plY3Qvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczIvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzIjsKaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gIi9ob21lL2pvYW5hL3Bhc3RhLXRlc3RlL3Byb2pldG8tdnVlL2Z1bmMtcHJvamVjdC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMi9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdCI7CgpmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfQoKZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9CgpmdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSAidW5kZWZpbmVkIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAobyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkpIHsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC4iKTsgfSB2YXIgaXQsIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfQoKZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSAic3RyaW5nIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09ICJPYmplY3QiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSAiTWFwIiB8fCBuID09PSAiU2V0IikgcmV0dXJuIEFycmF5LmZyb20obik7IGlmIChuID09PSAiQXJndW1lbnRzIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH0KCmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfQoKaW1wb3J0IHsgY2FtZWxpemUgfSBmcm9tICIuL2hlbHBlcnMiOwp2YXIgcGF0dGVybiA9IHsKICBzdHlsZUxpc3Q6IC87KD8hW14oXSpcKSkvZywKICBzdHlsZVByb3A6IC86KC4qKS8KfTsKCmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGUpIHsKICB2YXIgc3R5bGVNYXAgPSB7fTsKCiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0eWxlLnNwbGl0KHBhdHRlcm4uc3R5bGVMaXN0KSksCiAgICAgIF9zdGVwOwoKICB0cnkgewogICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgdmFyIHMgPSBfc3RlcC52YWx1ZTsKCiAgICAgIHZhciBfcyRzcGxpdCA9IHMuc3BsaXQocGF0dGVybi5zdHlsZVByb3ApLAogICAgICAgICAgX3Mkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3Mkc3BsaXQsIDIpLAogICAgICAgICAga2V5ID0gX3Mkc3BsaXQyWzBdLAogICAgICAgICAgdmFsID0gX3Mkc3BsaXQyWzFdOwoKICAgICAga2V5ID0ga2V5LnRyaW0oKTsKCiAgICAgIGlmICgha2V5KSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0gLy8gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgYGtleTogdmFsdWVgIHBhaXIgaXMgaW5jb21wbGV0ZS4KCgogICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgICAgICB2YWwgPSB2YWwudHJpbSgpOwogICAgICB9CgogICAgICBzdHlsZU1hcFtjYW1lbGl6ZShrZXkpXSA9IHZhbDsKICAgIH0KICB9IGNhdGNoIChlcnIpIHsKICAgIF9pdGVyYXRvci5lKGVycik7CiAgfSBmaW5hbGx5IHsKICAgIF9pdGVyYXRvci5mKCk7CiAgfQoKICByZXR1cm4gc3R5bGVNYXA7Cn0KCmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlRGF0YSgpIHsKICB2YXIgbWVyZ2VUYXJnZXQgPSB7fTsKICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgdmFyIHByb3A7CiAgdmFyIGV2ZW50OyAvLyBBbGxvdyBmb3IgdmFyaWFkaWMgYXJndW1lbnQgbGVuZ3RoLgoKICB3aGlsZSAoaS0tKSB7CiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGRhdGEgcHJvcGVydGllcyBhbmQgZXhlY3V0ZSBtZXJnZSBzdHJhdGVnaWVzCiAgICAvLyBPYmplY3Qua2V5cyBlbGltaW5hdGVzIG5lZWQgZm9yIGhhc093blByb3BlcnR5IGNhbGwKICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzW2ldKTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7CiAgICAgIHByb3AgPSBfT2JqZWN0JGtleXNbX2ldOwoKICAgICAgc3dpdGNoIChwcm9wKSB7CiAgICAgICAgLy8gQXJyYXkgbWVyZ2Ugc3RyYXRlZ3kgKGFycmF5IGNvbmNhdGVuYXRpb24pCiAgICAgICAgY2FzZSAnY2xhc3MnOgogICAgICAgIGNhc2UgJ3N0eWxlJzoKICAgICAgICBjYXNlICdkaXJlY3RpdmVzJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXJnZVRhcmdldFtwcm9wXSkpIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBbXTsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAocHJvcCA9PT0gJ3N0eWxlJykgewogICAgICAgICAgICB2YXIgc3R5bGUgPSB2b2lkIDA7CgogICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbaV0uc3R5bGUpKSB7CiAgICAgICAgICAgICAgc3R5bGUgPSBhcmd1bWVudHNbaV0uc3R5bGU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgc3R5bGUgPSBbYXJndW1lbnRzW2ldLnN0eWxlXTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHlsZS5sZW5ndGg7IGorKykgewogICAgICAgICAgICAgIHZhciBzID0gc3R5bGVbal07CgogICAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgICAgICAgIHN0eWxlW2pdID0gcGFyc2VTdHlsZShzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGFyZ3VtZW50c1tpXS5zdHlsZSA9IHN0eWxlOwogICAgICAgICAgfSAvLyBSZXBhY2thZ2luZyBpbiBhbiBhcnJheSBhbGxvd3MgVnVlIHJ1bnRpbWUKICAgICAgICAgIC8vIHRvIG1lcmdlIGNsYXNzL3N0eWxlIGJpbmRpbmdzIHJlZ2FyZGxlc3Mgb2YgdHlwZS4KCgogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSBtZXJnZVRhcmdldFtwcm9wXS5jb25jYXQoYXJndW1lbnRzW2ldW3Byb3BdKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIFNwYWNlIGRlbGltaXRlZCBzdHJpbmcgY29uY2F0ZW5hdGlvbiBzdHJhdGVneQoKICAgICAgICBjYXNlICdzdGF0aWNDbGFzcyc6CiAgICAgICAgICBpZiAoIWFyZ3VtZW50c1tpXVtwcm9wXSkgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KCiAgICAgICAgICBpZiAobWVyZ2VUYXJnZXRbcHJvcF0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9ICcnOwogICAgICAgICAgfQoKICAgICAgICAgIGlmIChtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICAvLyBOb3QgYW4gZW1wdHkgc3RyaW5nLCBzbyBjb25jYXRlbmF0ZQogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSArPSAnICc7CiAgICAgICAgICB9CgogICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gKz0gYXJndW1lbnRzW2ldW3Byb3BdLnRyaW0oKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIE9iamVjdCwgdGhlIHByb3BlcnRpZXMgb2Ygd2hpY2ggdG8gbWVyZ2UgdmlhIGFycmF5IG1lcmdlIHN0cmF0ZWd5IChhcnJheSBjb25jYXRlbmF0aW9uKS4KICAgICAgICAvLyBDYWxsYmFjayBtZXJnZSBzdHJhdGVneSBtZXJnZXMgY2FsbGJhY2tzIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5LAogICAgICAgIC8vIHNvIHRoYXQgdGhlIGxhc3QgZGVmaW5lZCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgZmlyc3QuCiAgICAgICAgLy8gVGhpcyBpcyBkb25lIHNpbmNlIHRvIG1pbWljIGhvdyBPYmplY3QuYXNzaWduIG1lcmdpbmcKICAgICAgICAvLyB1c2VzIHRoZSBsYXN0IGdpdmVuIHZhbHVlIHRvIGFzc2lnbi4KCiAgICAgICAgY2FzZSAnb24nOgogICAgICAgIGNhc2UgJ25hdGl2ZU9uJzoKICAgICAgICAgIGlmICghYXJndW1lbnRzW2ldW3Byb3BdKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghbWVyZ2VUYXJnZXRbcHJvcF0pIHsKICAgICAgICAgICAgbWVyZ2VUYXJnZXRbcHJvcF0gPSB7fTsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gbWVyZ2VUYXJnZXRbcHJvcF07CgogICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX09iamVjdCRrZXlzMiA9IE9iamVjdC5rZXlzKGFyZ3VtZW50c1tpXVtwcm9wXSB8fCB7fSk7IF9pMiA8IF9PYmplY3Qka2V5czIubGVuZ3RoOyBfaTIrKykgewogICAgICAgICAgICBldmVudCA9IF9PYmplY3Qka2V5czJbX2kyXTsKCiAgICAgICAgICAgIC8vIENvbmNhdCBmdW5jdGlvbiB0byBhcnJheSBvZiBmdW5jdGlvbnMgaWYgY2FsbGJhY2sgcHJlc2VudC4KICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tldmVudF0pIHsKICAgICAgICAgICAgICAvLyBJbnNlcnQgY3VycmVudCBpdGVyYXRpb24gZGF0YSBpbiBiZWdpbm5pbmcgb2YgbWVyZ2VkIGFycmF5LgogICAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBBcnJheSgpLmNvbmNhdCggLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0sIGFyZ3VtZW50c1tpXVtwcm9wXVtldmVudF0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIC8vIFN0cmFpZ2h0IGFzc2lnbi4KICAgICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gYXJndW1lbnRzW2ldW3Byb3BdW2V2ZW50XTsKICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIC8vIE9iamVjdCBtZXJnZSBzdHJhdGVneQoKICAgICAgICBjYXNlICdhdHRycyc6CiAgICAgICAgY2FzZSAncHJvcHMnOgogICAgICAgIGNhc2UgJ2RvbVByb3BzJzoKICAgICAgICBjYXNlICdzY29wZWRTbG90cyc6CiAgICAgICAgY2FzZSAnc3RhdGljU3R5bGUnOgogICAgICAgIGNhc2UgJ2hvb2snOgogICAgICAgIGNhc2UgJ3RyYW5zaXRpb24nOgogICAgICAgICAgaWYgKCFhcmd1bWVudHNbaV1bcHJvcF0pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKCFtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IHt9OwogICAgICAgICAgfQoKICAgICAgICAgIG1lcmdlVGFyZ2V0W3Byb3BdID0gX29iamVjdFNwcmVhZCh7fSwgYXJndW1lbnRzW2ldW3Byb3BdLCB7fSwgbWVyZ2VUYXJnZXRbcHJvcF0pOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgLy8gUmVhc3NpZ25tZW50IHN0cmF0ZWd5IChubyBtZXJnZSkKCiAgICAgICAgY2FzZSAnc2xvdCc6CiAgICAgICAgY2FzZSAna2V5JzoKICAgICAgICBjYXNlICdyZWYnOgogICAgICAgIGNhc2UgJ3RhZyc6CiAgICAgICAgY2FzZSAnc2hvdyc6CiAgICAgICAgY2FzZSAna2VlcEFsaXZlJzoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgaWYgKCFtZXJnZVRhcmdldFtwcm9wXSkgewogICAgICAgICAgICBtZXJnZVRhcmdldFtwcm9wXSA9IGFyZ3VtZW50c1tpXVtwcm9wXTsKICAgICAgICAgIH0KCiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBtZXJnZVRhcmdldDsKfQ=="},{"version":3,"sources":["../../src/util/mergeData.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n  let event: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = []\n          }\n\n          if (prop === 'style') {\n            let style: any[]\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style\n            } else {\n              style = [arguments[i].style]\n            }\n            for (let j = 0; j < style.length; j++) {\n              const s = style[j]\n              if (typeof s === 'string') {\n                style[j] = parseStyle(s)\n              }\n            }\n            arguments[i].style = style\n          }\n\n          // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop])\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          const listeners = mergeTarget[prop]!\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array<Function>().concat( // eslint-disable-line\n                listeners[event],\n                arguments[i][prop][event]\n              )\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event]\n            }\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n"],"sourceRoot":""}]}